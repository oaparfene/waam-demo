/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useCallback } from 'react'
import { useGLTF } from '@react-three/drei'
import { ThreeEvent } from '@react-three/fiber'
import * as THREE from 'three'
import type { Mesh } from 'three'
import type { MeshVisibility, MaterialMode } from './mesh-visibility-panel'
import { DeviationMaterial } from '@/components/deviation-material'
import { RGBMaterial } from '@/components/rgb-material'

export interface VertexData {
  index: number
  position: { x: number; y: number; z: number }
  rgb?: { r: number; g: number; b: number }
  deposition?: { dx: number; dy: number; dz: number; magnitude: number }
}

interface RamlabMeshesProps {
  visibility?: MeshVisibility
  materialMode?: MaterialMode
  onVertexHover?: (data: VertexData | null) => void
  [key: string]: any
}

export function RamlabMeshes({ visibility, materialMode = 'gray', onVertexHover, ...props }: RamlabMeshesProps) {
  const { nodes } = useGLTF('/meshes/draco_prefix_meshattr.glb')
  
  // Default to all visible if no visibility prop provided
  const showTarget = visibility?.targetMesh ?? true
  const showResult = visibility?.resultMesh ?? true

  // Get the result mesh geometry
  const resultGeometry = (nodes.result_mesh as Mesh).geometry

  const handlePointerMove = useCallback((event: ThreeEvent<PointerEvent>) => {
    if (materialMode === 'gray' || !onVertexHover) return

    const face = event.face
    if (!face) {
      onVertexHover(null)
      return
    }

    // Get vertex indices from the face
    const faceVertices = [face.a, face.b, face.c]
    const intersectionPoint = event.point

    // Get position attribute
    const positionAttr = resultGeometry.getAttribute('position')
    if (!positionAttr) {
      onVertexHover(null)
      return
    }

    // Find nearest vertex to intersection point
    let nearestIndex = -1
    let nearestDistance = Infinity
    const tempVec = new THREE.Vector3()

    for (const vertexIndex of faceVertices) {
      tempVec.fromBufferAttribute(positionAttr, vertexIndex)
      // Apply the same scale as the mesh (0.01)
      tempVec.multiplyScalar(0.01)
      const distance = tempVec.distanceTo(intersectionPoint)
      if (distance < nearestDistance) {
        nearestDistance = distance
        nearestIndex = vertexIndex
      }
    }

    if (nearestIndex === -1) {
      onVertexHover(null)
      return
    }

    // Get position of nearest vertex
    const position = {
      x: positionAttr.getX(nearestIndex),
      y: positionAttr.getY(nearestIndex),
      z: positionAttr.getZ(nearestIndex),
    }

    // Build vertex data based on mode
    const data: VertexData = {
      index: nearestIndex,
      position,
    }

    if (materialMode === 'rgb') {
      // Get RGB from color attribute
      const colorAttr = resultGeometry.getAttribute('color')
      if (colorAttr) {
        let r: number, g: number, b: number
        
        // When normalized=true, getX/Y/Z returns floats in 0-1 range
        // When normalized=false, returns raw values based on array type
        if (colorAttr.normalized) {
          // Already normalized to 0-1, just multiply by 255
          r = Math.round(colorAttr.getX(nearestIndex) * 255)
          g = Math.round(colorAttr.getY(nearestIndex) * 255)
          b = Math.round(colorAttr.getZ(nearestIndex) * 255)
        } else if (colorAttr.array instanceof Uint16Array) {
          // Raw Uint16 (0-65535) -> 0-255
          r = Math.round((colorAttr.getX(nearestIndex) / 65535) * 255)
          g = Math.round((colorAttr.getY(nearestIndex) / 65535) * 255)
          b = Math.round((colorAttr.getZ(nearestIndex) / 65535) * 255)
        } else if (colorAttr.array instanceof Float32Array) {
          // Float (0-1) -> 0-255
          r = Math.round(colorAttr.getX(nearestIndex) * 255)
          g = Math.round(colorAttr.getY(nearestIndex) * 255)
          b = Math.round(colorAttr.getZ(nearestIndex) * 255)
        } else {
          // Assume Uint8 (0-255)
          r = Math.round(colorAttr.getX(nearestIndex))
          g = Math.round(colorAttr.getY(nearestIndex))
          b = Math.round(colorAttr.getZ(nearestIndex))
        }
        
        data.rgb = { r, g, b }
      }
    } else if (materialMode === 'deviation') {
      // Get deposition data from _dx, _dy, _dz attributes
      const dxAttr = resultGeometry.getAttribute('_dx')
      const dyAttr = resultGeometry.getAttribute('_dy')
      const dzAttr = resultGeometry.getAttribute('_dz')

      if (dxAttr && dyAttr && dzAttr) {
        const dx = dxAttr.getX(nearestIndex)
        const dy = dyAttr.getX(nearestIndex)
        const dz = dzAttr.getX(nearestIndex)
        const magnitude = Math.sqrt(dx * dx + dy * dy + dz * dz)
        data.deposition = { dx, dy, dz, magnitude }
      }
    }

    onVertexHover(data)
  }, [resultGeometry, materialMode, onVertexHover])

  const handlePointerLeave = useCallback(() => {
    onVertexHover?.(null)
  }, [onVertexHover])

  return (
    <group {...props} dispose={null} rotation={[0, Math.PI, 0]}>
      {showTarget && (
        <mesh
          castShadow
          receiveShadow
          geometry={(nodes.target_mesh as Mesh).geometry}
          material={(nodes.target_mesh as Mesh).material}
          scale={0.01}
        />
      )}
      {showResult && (
        <mesh
          castShadow
          receiveShadow
          geometry={resultGeometry}
          scale={0.01}
          onPointerMove={handlePointerMove}
          onPointerLeave={handlePointerLeave}
        >
          {materialMode === 'gray' && (
            <meshStandardMaterial 
              color="#888888"
              metalness={0.1}
              roughness={0.8}
            />
          )}
          {materialMode === 'rgb' && (
            <RGBMaterial />
          )}
          {materialMode === 'deviation' && (
            <DeviationMaterial />
          )}
        </mesh>
      )}
    </group>
  )
}

useGLTF.preload('/meshes/draco_prefix_meshattr.glb')
